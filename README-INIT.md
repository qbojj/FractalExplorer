# Procedural Fractal World Generator
## Initial Project Description - Procedural Content Generation Course

---

## Abstract

This project implements a **real-time procedural fractal world generator** using **GPU-accelerated ray marching** and **Iterated Function Systems (IFS)**. The system generates infinite 3D fractal landscapes through **space-folding operations** (box fold, sphere fold, tetrahedral symmetry), enabling **smooth interpolation** between different procedurally-generated worlds and **real-time parameter mutation**. By treating fractal parameters as a continuous space, the system allows seamless morphing between distinct configurations, creating interpolatable procedural worlds with mathematical precision and visual coherence.

---

## Background and Motivation

### Scientific Foundation

**Procedural Content Generation (PCG)** has become essential for creating vast, diverse virtual environments without manual authoring. While traditional PCG often focuses on terrain generation using noise functions (Perlin, Simplex), **fractal-based generation** offers unique advantages:

1. **Infinite detail** at all scales through self-similarity
2. **Mathematical precision** via Iterated Function Systems [1]
3. **Compact representation** - complex structures from simple rules
4. **Natural parameter spaces** enabling interpolation

**Iterated Function Systems (IFS)** generate fractals by repeatedly applying transformations (folding, scaling, rotation) to points in 3D space [1]. Classic examples include the Sierpinski triangle, Menger sponge, and Mandelbox. These structures exhibit self-similarity and can represent complex organic or architectural forms.

**Ray Marching with SDFs** provides an efficient rendering technique for implicit surfaces [2]. Sphere tracing [3] allows real-time visualization of mathematically-defined fractals without polygon meshes, making it ideal for dynamic procedural generation.

### Problem Statement

Current procedural generation systems typically produce **discrete, isolated worlds**. Interpolating between different random seeds often results in visual artifacts and loss of structural coherence. 

**Research Question:** How can we design procedural generation systems where worlds exist in a **continuous parameter space** that supports meaningful interpolation?

### Project Motivation

This project explores **interpolatable procedural worlds** - a parameter space design where:
- Linear parameter interpolation produces visually coherent intermediate states
- Worlds can smoothly morph from one configuration to another
- Parameter mutations preserve structural properties
- Real-time exploration enables interactive navigation through "world space"

**Potential Applications:**
- Dynamic game environments that evolve based on player actions
- Adaptive difficulty through world mutation
- Procedural narrative generation tied to environment
- VR experiences with seamless world transitions
- Art installations with evolving fractal landscapes

---

## Project Goals

### Primary Objectives

1. **Fractal Generation System**
   - Implement 3+ IFS fractal types (Mandelbox, Menger sponge, Sierpinski)
   - Space-folding operations library (box fold, sphere fold, rotations)
   - Efficient SDF evaluation for ray marching

2. **Interpolatable Parameter Space**
   - Design continuous parameter representations
   - Implement smooth interpolation between world configurations
   - Validate visual coherence of interpolated states

3. **Real-Time World Mutation**
   - Parameter perturbation within valid ranges
   - Constraint preservation (stability, visual quality)
   - Interactive parameter control interface

4. **Performance Achievement**
   - GPU-accelerated rendering (60+ FPS target)
   - Real-time parameter updates (<16ms latency)
   - Support for complex fractal configurations

### Expected Deliverables

- **Fractal Library:** Minimum 3 distinct fractal types with documented parameters
- **World Presets:** 5+ hand-crafted configurations demonstrating variety
- **Interpolation Engine:** Smooth morphing system with configurable easing
- **Mutation System:** Procedural parameter evolution with quality metrics
- **Interactive Demo:** Real-time exploration with parameter controls
- **Technical Report:** Algorithm analysis, parameter space study, performance evaluation

---

## Methodology

### 4.1 Fractal Generation Algorithms

**Iterated Function System (IFS) Approach**

Fractals are generated by iteratively applying transformations to points in homogeneous coordinates:

```
Input: point p ∈ ℝ³, parameters θ
Output: distance to fractal surface

z ← (p, 1)  // Homogeneous coordinates for scale tracking
for i = 1 to ITERATIONS:
    apply_folding_operations(z, θ)
    z ← z · scale + offset
return distance_estimator(z)
```

**Folding Operations:**

1. **Box Fold** - Mirror reflection at box boundaries
   - Creates cubic symmetry
   - Parameter: fold radius r ∈ ℝ³

2. **Sphere Fold** - Inversion around sphere
   - Creates radial patterns
   - Parameters: min/max radius (r_min, r_max)

3. **Menger Fold** - Recursive subdivision
   - Creates cube-based structures
   - Implements coordinate permutations

4. **Sierpinski Fold** - Tetrahedral symmetry
   - Creates pyramid-like structures
   - Implements conditional reflections

**Fractal Types to Implement:**

- **Mandelbox:** Combines box fold + sphere fold + scaling [4]
  - Parameters: scale ∈ [1.5, 3.0], r_min ∈ [0.1, 1.0], r_max ∈ [0.5, 2.0]
  
- **Menger Sponge:** Menger fold + scaling iterations
  - Parameters: scale factor, iteration count
  
- **Sierpinski Tetrahedron:** Tetrahedral fold + translation
  - Parameters: scale = 2.0, offset vector
  
- **Hybrid Fractals:** Composition of multiple fold types
  - Custom parameter combinations for novel structures

### 4.2 Parameter Space Design

**Continuous Parameter Representation:**

```
WorldParams = {
    scale: ℝ⁺,
    minRadius: ℝ⁺,
    maxRadius: ℝ⁺,
    foldRadius: ℝ³,
    offset: ℝ³,
    iterations: ℤ⁺,
    rotationAngle: ℝ,
    colorParams: ℝⁿ
}
```

**Design Principles:**
1. **Boundedness:** All parameters have valid ranges to ensure stability
2. **Continuity:** Small parameter changes → small visual changes
3. **Expressiveness:** Parameter space spans diverse visual appearances
4. **Interpolability:** Linear interpolation produces meaningful results

**Interpolation Strategy:**

```
lerp(θ₁, θ₂, t) = (1-t)·θ₁ + t·θ₂,  t ∈ [0,1]

smooth_lerp(θ₁, θ₂, t) = lerp(θ₁, θ₂, smoothstep(t))
where smoothstep(t) = 3t² - 2t³
```

For discrete parameters (iterations):
```
iterations_interp = round(lerp(iter₁, iter₂, t))
```

### 4.3 Mutation Algorithms

**Parameter Perturbation:**

```
mutate(θ, σ) = θ + N(0, σ²)
where N(0, σ²) is Gaussian noise, σ controls mutation strength
```

With constraints:
```
θ_mutated = clamp(θ + δ, θ_min, θ_max)
```

**Guided Mutation:**

- **Diversity Metric:** Measure visual difference from existing worlds
- **Stability Metric:** Ensure SDF remains well-behaved
- **Aesthetic Metric:** Heuristics for visual interest

### 4.4 Rendering via Ray Marching

**Sphere Tracing Algorithm [3]:**

```
Given: ray origin O, direction D, fractal SDF
Output: intersection point or miss

t ← 0
for step = 1 to MAX_STEPS:
    p ← O + t·D
    dist ← fractal_SDF(p, params)
    
    if dist < ε:  // Hit!
        return (HIT, p, t)
    
    t ← t + dist  // Safe to step by distance
    
    if t > MAX_DIST:
        break

return MISS
```

**GPU Parallelization:**
- Each pixel processed independently by one CUDA thread
- Expected 50-200× speedup over CPU
- Target: 60+ FPS at 1920×1080

### 4.5 Evaluation Methodology

**Quantitative Metrics:**
1. **Performance:** Frame rate, rendering time, parameter update latency
2. **Parameter Space Coverage:** Diversity of generated worlds
3. **Interpolation Smoothness:** Visual continuity metric

**Qualitative Assessment:**
1. **Visual Quality:** Structural coherence, aesthetic appeal
2. **Interpolation Quality:** Smoothness of transitions
3. **Mutation Viability:** Proportion of stable/interesting mutations

**Comparative Analysis:**
- Different fractal types (complexity vs performance)
- Iteration counts (detail vs frame rate)
- Interpolation methods (linear vs eased)
- Parameter ranges (stable vs chaotic regions)

---

## Bibliography and References

[1] Barnsley, M. (1993). *Fractals Everywhere*. Academic Press Professional. (Foundational work on Iterated Function Systems)

[2] Wikipedia. "Signed Distance Function". https://en.wikipedia.org/wiki/Signed_distance_function (Comprehensive overview of SDFs in computer graphics)

[3] Hart, J. C. (1996). "Sphere Tracing: A Geometric Method for the Antialiased Ray Tracing of Implicit Surfaces". *The Visual Computer*, 12(10), 527-545. (Seminal paper on ray marching optimization)

[4] Leys, T. (2010). "Mandelbox". *FractalForums*. http://www.fractalforums.com/3d-fractal-generation/amazing-fractal/ (Introduction to Mandelbox fractal)

[5] Quilez, I. "Distance Functions". https://iquilezles.org/articles/distfunctions/ (Comprehensive distance function library and techniques)

[6] Smelik, R. M., et al. (2014). "A Survey on Procedural Modelling for Virtual Worlds". *Computer Graphics Forum*, 33(6), 31-50. (Survey of PCG techniques)

[7] Ebert, D. S., et al. (2003). *Texturing and Modeling: A Procedural Approach*. Morgan Kaufmann. (Classic procedural generation reference)

[8] Shiffman, D. (2012). *The Nature of Code*. Self-published. (Accessible introduction to procedural generation algorithms)

---

## Technical Stack

**Core Technologies:**
- **Language:** C++17 (CPU), CUDA (GPU kernels)
- **Graphics:** OpenGL/SDL2 for display
- **Mathematics:** GLM library
- **Build System:** CMake 3.18+

**Development Platforms:**
- Primary: Linux
- GPU: NVIDIA (Compute Capability 6.0+)

